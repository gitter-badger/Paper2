---
title: "New dist"
author: "Chase Clark"
date: "January 9, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```







```{r}
library("MALDIquant")
# mqPeaks<-readRDS("C:/Users/CMC/Desktop/Example/Peak_Lists/31-2_ProteinPeaks.rds")



mqPeaks<-list.files("C:/Users/CMC/Desktop/Example/Peak_Lists/",full.names = T,ignore.case = T)[grep("proteinpeaks", list.files("C:/Users/CMC/Desktop/Example/Peak_Lists/",full.names = T),ignore.case = T)]

mqPeaks <- sapply(mqPeaks,readRDS)

# input is just a vector of masses and a ppm value
ppmAcrossVector<-function(massVector,ppm){massVector * .0000001 * ppm}

```




Now we count the matches of spectra2 to spectra1
```{r}

#countMatches <- sum(sapply(matched,function(x) !!length(x)))

```

That's good to save for later... but... length(unlist(matched)) is more transparent/easy to understand





```{r}

poop <- unlist(mqPeaks)
names(poop) <- as.vector(sapply(poop,function(x)metaData(x)$Strain))
# unlist() because spectra groups stored as list of list
peakLists <- lapply(unlist(mqPeaks),mass)



   
# Let's explain this ->  peakLists[pairs[1]][[1]][x]
# "peakLists" is a list of mass vectors, each sample is an element in the list
# "pairs" has two values (comes from "pairwiseCombinations" which is a list of every combination of samples) 
# so... "peakLists[pairs[1]][[1]][x]"... means return a certain peak vector and we'll iterate over the values in the first peak list.
   
#ppmVector <- ppmAcrossVector(mqPeaks[[1]],10)

    ppmVector <- ppmAcrossVector(peakLists[[1]],10)




  peakMatching<-function(pairs) {lapply(seq_along(peakLists[pairs[1]][[1]]),function(x){
    ppmVector <- ppmAcrossVector(peakLists[pairs[1]][[1]],10)

                    which(peakLists[pairs[2]][[1]] <= peakLists[pairs[1]][[1]][x]+ppmVector[x] & peakLists[pairs[2]][[1]] >= peakLists[pairs[1]][[1]][x]-ppmVector[x])
  }
              )}

  
    
  
  
  
  pairwiseCombinations<-as.data.frame(combn(seq_along(peakLists), 2))

  
  
  # Run peakMatching pairwise
  matchedSamples <- lapply(pairwiseCombinations,peakMatching)
  

```


count matches
```{r}


lecou<-as.vector(unlist(lapply(matchedSamples,function(x) length(unlist(x)))))


```


Fix names
```{r}
sampleNames <- as.vector(unlist(lapply(unlist(mqPeaks),function(x)metaData(x)$Strain)))

orderOfNamesIndices<-as.data.frame(t(pairwiseCombinations))



a<-factor(orderOfNamesIndices[,1])
b<-lapply(levels(a),function(x)which(a == x))



c<-factor(orderOfNamesIndices[,2])
d<-lapply(levels(c),function(x)which(c == x))

```


Create a lower-left "distance matrix" triangle. YES!!!
```{r}

factorized<-factor(orderOfNamesIndices[,1])
# list of indices of samples
groupedBySample<-lapply(levels(a),function(x)which(a == x))


re<-sapply(as.numeric(levels(factorized)),function(x) c(rep(NA,times=x),lecou[groupedBySample[[x]]]))



```




```{r}
library(dplyr)
as_tibble(re)
```









Basically we made a one-traingle dist matrix:
 eg 312 spectra:
                 ((312*312)-312)/2
 
 
 
 
